#' @title One MCMC per model with multiple outputs.
#' @export
#' @description Targets to run a JAGS model once with MCMC
#'   and save multiple outputs.
#' @details The MCMC targets use `R2jags::jags()` if `n.cluster` is `1` and
#'   `R2jags::jags.parallel()` otherwise. Most arguments to `tar_jags_mcmc()`
#'   are forwarded to these functions.
#' @return `tar_jags_mcmc(name = x, jags_files = "y.jags", ...)` returns a list
#'   of `targets::tar_target()` objects:
#'   * `x_file_y`: reproducibly track the JAGS model file.
#'   * `x_lines_y`: contents of the JAGS model file.
#'     Omitted if `compile = "original"`.
#'   * `x_data`: data for the MCMC.
#'   * `x_mcmc_y`: `rjags` object from `R2jags` with all the MCMC results.
#'   * `x_draws_y`: tidy data frame of MCMC draws. Omitted if `draws = FALSE`.
#'   * `x_summary_y`: tidy data frame of MCMC summaries.
#'     Omitted if `summary = FALSE`.
#'   * `x_dic`: tidy data frame of deviance information criterion (DIC) info.
#'     Omitted if `dic = FALSE`.
#'  If you supply multiple models, you will get more (model-specific) targets.
#'  All the models share the same dataset.
#' @inheritParams R2jags::jags
#' @inheritParams R2jags::jags.parallel
#' @inheritParams targets::tar_target
#' @param name Symbol, base name for the collection of targets.
#'   Serves as a prefix for target names.
#' @param data Code to generate the `data` for the JAGS model.
#' @param jags_files Character vector of JAGS model files. If you
#'   supply multiple files, each model will run on the one shared dataset
#'   generated by the code in `data`. If you supply an unnamed vector,
#'   `tools::file_path_sans_ext(basename(jags_files))` will be used
#'   as target name suffixes. If `jags_files` is a named vector,
#'   the suffixed will come from `names(jags_files)`.
#' @param target_draws Logical, whether to create a target for posterior draws.
#'   Saves `posterior::as_draws_df(fit$draws())` to a compressed `tibble`.
#'   Convenient, but duplicates storage.
#' @param target_summary Logical, whether to create a target to store a small
#'   data frame of posterior summary statistics and convergence diagnostics.
#' @param target_dic Logical, whether to create a target with deviance
#'   information criterion (DIC) results.
#' @examples
#' # First, write your JAGS model file. Example:
#' # tar_jags_example_file() # Writes jagstargets_example.jags
#' # Then in _targets.R, write the pipeline:
#' targets::tar_pipeline(
#'   tar_jags_mcmc(
#'     your_model,
#'     jags_files = "jagstargets_example.jags",
#'     data = tar_jags_example_data()
#'   )
#' )
tar_jags_mcmc <- function(
  name,
  jags_files,
  parameters.to.save,
  data = list(),
  inits = NULL,
  n.cluster = 1,
  n.chains = 3,
  n.iter = 2e3,
  n.burn = floor(n.iter / 2),
  n.thin = max(1, floor((n.iter - n.burnin) / 1000)),
  DIC = TRUE,
  jags.module = c("glm","dic")
  RNGname = c(
    "Wichmann-Hill",
    "Marsaglia-Multicarry",
    "Super-Duper",
    "Mersenne-Twister"
  ),
  jags.seed = 123,
  refresh = n.iter / 50,
  progress.bar = "text",
  draws = TRUE,
  summary = TRUE,
  dic = TRUE,
  tidy_eval = targets::tar_option_get("tidy_eval"),
  packages = targets::tar_option_get("packages"),
  library = targets::tar_option_get("library"),
  error = targets::tar_option_get("error"),
  memory = targets::tar_option_get("memory"),
  garbage_collection = targets::tar_option_get("garbage_collection"),
  deployment = targets::tar_option_get("deployment"),
  priority = targets::tar_option_get("priority"),
  resources = targets::tar_option_get("resources"),
  storage = targets::tar_option_get("storage"),
  retrieval = targets::tar_option_get("retrieval"),
  cue = targets::tar_option_get("cue")
) {
  envir <- tar_option_get("envir")
  assert_chr(jags_files)
  assert_unique(jags_files)
  name <- deparse_language(substitute(name))
  name_JAGS <- produce_JAGS_names(jags_files)
  name_file <- paste0(name, "_file")
  name_lines <- paste0(name, "_lines")
  name_data <- paste0(name, "_data")
  name_mcmc <- paste0(name, "_mcmc")
  name_draws <- paste0(name, "_draws")
  name_summary <- paste0(name, "_summary")
  name_diagnostics <- paste0(name, "_diagnostics")
  sym_JAGS <- rlang::syms(name_JAGS)
  sym_file <- rlang::sym(name_file)
  sym_lines <- rlang::sym(name_lines)
  sym_data <- rlang::sym(name_data)
  sym_mcmc <- rlang::sym(name_mcmc)
  command_lines <- call_function(
    "readLines",
    args = list(con = rlang::sym(name_file))
  )
  command_data <- tidy_eval(
    substitute(data),
    envir = envir,
    tidy_eval = tidy_eval
  )
  command_draws <- substitute(
    tibble::as_tibble(posterior::as_draws_df(
      fit$draws(variables = variables, inc_warmup = inc_warmup)
    )),
    env = list(
      fit = sym_mcmc,
      variables = variables,
      inc_warmup = inc_warmup
    )
  )
  method_summary <- call_function("$", list(sym_mcmc, rlang::sym("summary")))
  args_summary <- list(method_summary)
  summaries <- as.list(substitute(summaries)[-1])
  for (index in seq_along(summaries)) {
    args_summary[[index + 1]] <- summaries[[index]]
  }
  args_summary$variables <- variables %||% quote(identity(NULL))
  args_summary$.args <- substitute(summary_args)
  command_summary <- as.expression(as.call(args_summary))
  command_diagnostics <- substitute(
    tibble::as_tibble(
      posterior::as_draws_df(.targets_mcmc$sampler_diagnostics())
    ),
    env = list(.targets_mcmc = sym_mcmc)
  )
  args_mcmc <- list(
    call_ns("JAGStargets", "tar_jags_mcmc_run"),
    JAGS_file = trn(identical(compile, "original"), sym_file, sym_lines),
    data = sym_data,
    compile = compile,
    quiet = quiet,
    dir = dir,
    include_paths = include_paths,
    cpp_options = cpp_options,
    JAGSc_options = JAGSc_options,
    force_recompile = force_recompile,
    seed = seed,
    refresh = refresh,
    init = init,
    save_latent_dynamics = save_latent_dynamics,
    output_dir = output_dir,
    chains = chains,
    parallel_chains = parallel_chains,
    chain_ids = chain_ids,
    threads_per_chain = threads_per_chain,
    iter_warmup = iter_warmup,
    iter_sampling = iter_sampling,
    save_warmup = save_warmup,
    thin = thin,
    max_treedepth = max_treedepth,
    adapt_engaged = adapt_engaged,
    adapt_delta = adapt_delta,
    step_size = step_size,
    metric = metric,
    metric_file = metric_file,
    inv_metric = inv_metric,
    init_buffer = init_buffer,
    term_buffer = term_buffer,
    window = window,
    fixed_param = fixed_param,
    sig_figs = sig_figs,
    validate_csv = validate_csv,
    show_messages = show_messages,
    variables = variables,
    inc_warmup = inc_warmup
  )
  command_mcmc <- as.expression(as.call(args_mcmc))
  target_file <- targets::tar_target_raw(
    name = name_file,
    command = quote(._JAGStargets_file_50e43091),
    packages = character(0),
    format = "file",
    error = error,
    memory = memory,
    garbage_collection = garbage_collection,
    deployment = "main",
    priority = priority,
    cue = cue
  )
  target_lines <- targets::tar_target_raw(
    name = name_lines,
    command = command_lines,
    packages = character(0),
    error = error,
    memory = memory,
    garbage_collection = garbage_collection,
    deployment = "main",
    priority = priority,
    cue = cue
  )
  target_data <- targets::tar_target_raw(
    name = name_data,
    command = command_data,
    packages = packages,
    library = library,
    format = "qs",
    error = error,
    memory = memory,
    garbage_collection = garbage_collection,
    deployment = deployment,
    priority = priority,
    cue = cue
  )
  target_mcmc <- targets::tar_target_raw(
    name = name_mcmc,
    command = command_mcmc,
    format = "qs",
    packages = character(0),
    error = error,
    memory = memory,
    garbage_collection = garbage_collection,
    deployment = deployment,
    priority = priority,
    resources = resources,
    storage = storage,
    retrieval = retrieval,
    cue = cue
  )
  target_draws <- targets::tar_target_raw(
    name = name_draws,
    command = command_draws,
    packages = character(0),
    format = "fst_tbl",
    error = error,
    memory = memory,
    garbage_collection = garbage_collection,
    deployment = deployment,
    priority = priority,
    cue = cue
  )
  target_summary <- targets::tar_target_raw(
    name = name_summary,
    command = command_summary,
    packages = character(0),
    format = "fst_tbl",
    error = error,
    memory = memory,
    garbage_collection = garbage_collection,
    deployment = deployment,
    priority = priority,
    cue = cue
  )
  target_diagnostics <- targets::tar_target_raw(
    name = name_diagnostics,
    command = command_diagnostics,
    packages = character(0),
    format = "fst_tbl",
    error = error,
    memory = memory,
    garbage_collection = garbage_collection,
    deployment = deployment,
    priority = priority,
    cue = cue
  )
  out <- list(
    target_file,
    trn(identical(compile, "original"), NULL, target_lines),
    target_mcmc,
    trn(identical(draws, TRUE), target_draws, NULL),
    trn(identical(summary, TRUE), target_summary, NULL),
    trn(identical(diagnostics, TRUE), target_diagnostics, NULL)
  )
  out <- list_nonempty(out)
  values <- list(
    ._JAGStargets_file_50e43091 = jags_files,
    ._JAGStargets_name_50e43091 = sym_JAGS
  )
  out <- tarchetypes::tar_map(
    values = values,
    names = ._JAGStargets_name_50e43091,
    unlist = TRUE,
    out
  )
  out[[name_data]] <- target_data
  out
}

#' @title Compile and run a JAGS model and return the `CmdJAGSFit` object.
#' @export
#' @keywords internal
#' @description Not a user-side function. Do not invoke directly.
#' @return A `CmdJAGSFit` object.
#' @inheritParams cmdJAGSr::cmdJAGS_model
#' @inheritParams cmdJAGSr::`model-method-sample`
#' @param compile Character of length 1. If `"original"`, then
#'   `cmdJAGS` will compile the source file right before running
#'   it (or skip compilation if the binary is up to date). This
#'   assumes the worker has access to the file. If the worker
#'   is running on a remote computer that does not have access
#'   to the model file, set to `"copy"` instead. `compile = "copy"`
#'   means the pipeline will read the lines of the original JAGS model file
#'   and send them to the worker. The worker writes the lines
#'   to a local copy and compiles the model from there, so it
#'   no longer needs access to the original JAGS model file on your
#'   local machine. However, as a result, the JAGS model re-compiles
#'   every time the main target reruns.
tar_jags_mcmc_run <- function(
  JAGS_file,
  data,
  compile,
  quiet,
  dir,
  include_paths,
  cpp_options,
  JAGSc_options,
  force_recompile,
  seed,
  refresh,
  init,
  save_latent_dynamics,
  output_dir,
  chains,
  parallel_chains,
  chain_ids,
  threads_per_chain,
  iter_warmup,
  iter_sampling,
  save_warmup,
  thin,
  max_treedepth,
  adapt_engaged,
  adapt_delta,
  step_size,
  metric,
  metric_file,
  inv_metric,
  init_buffer,
  term_buffer,
  window,
  fixed_param,
  sig_figs,
  validate_csv,
  show_messages,
  variables,
  inc_warmup
) {
  file <- JAGS_file
  if (identical(compile, "copy")) {
    tmp <- tempfile(fileext = ".JAGS")
    writeLines(JAGS_file, tmp)
    file <- tmp
  }
  model <- cmdJAGSr::cmdJAGS_model(
    JAGS_file = file,
    compile = TRUE,
    quiet = quiet,
    dir = dir,
    include_paths = include_paths,
    cpp_options = cpp_options,
    JAGSc_options = JAGSc_options,
    force_recompile = force_recompile
  )
  if (is.null(seed)) {
    seed <- abs(targets::tar_seed()) + 1L
  }
  fit <- model$sample(
    data = data,
    seed = seed,
    refresh = refresh,
    init = init,
    save_latent_dynamics = save_latent_dynamics,
    output_dir = output_dir,
    chains = chains,
    parallel_chains = parallel_chains,
    chain_ids = chain_ids,
    threads_per_chain = threads_per_chain,
    iter_warmup = iter_warmup,
    iter_sampling = iter_sampling,
    save_warmup = save_warmup,
    thin = thin,
    max_treedepth = max_treedepth,
    adapt_engaged = adapt_engaged,
    adapt_delta = adapt_delta,
    step_size = step_size,
    metric = metric,
    metric_file = metric_file,
    inv_metric = inv_metric,
    init_buffer = init_buffer,
    term_buffer = term_buffer,
    window = window,
    fixed_param = fixed_param,
    sig_figs = sig_figs,
    validate_csv = validate_csv,
    show_messages = show_messages
  )
  # Load all the data and return the whole unserialized fit object:
  # https://github.com/JAGS-dev/cmdJAGSr/blob/d27994f804c493ff3047a2a98d693fa90b83af98/R/fit.R#L16-L18 # nolint
  fit$draws() # Do not specify variables or inc_warmup.
  try(fit$sampler_diagnostics(), silent = TRUE)
  try(fit$init(), silent = TRUE)
  fit
}
